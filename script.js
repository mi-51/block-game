// ゲームに関する設定を表す定数
const ゲーム盤の行の数 = 12;  // ゲーム盤の大きさ
const ゲーム盤の列の数 = 12;
const マスの大きさ = 20;      // ゲーム盤のマスの大きさ
const ゲーム盤の位置x = 10.5; // ゲーム盤の表示位置
const ゲーム盤の位置y = 10.5;
const キャンバスの幅 = 400;   // キャンバスの大きさ
const キャンバスの高さ = 400;
const ブロックの色 = [        // ブロックの番号に対応するブロックの色を表す配列
  "red", "blue", "green", "orange", "yellow", "purple", "lightblue",
];

// ゲームで使用する様々な大域変数
let canvas; // キャンバスの要素オブジェクト
let ctx;    // キャンバスの描画コンテキスト
let ゲーム盤のブロック;  // ゲーム盤に配置されたブロックの番号を表す2次元配列
// 操作するポリオミノのデータを記憶するオブジェクト
// 以下のプロパティを持つ
//   x, y:        ポリオミノのゲーム盤上の座標
//   種類:        ポリオミノの種類を表す表す番号
//   色:          ポリオミノのブロックの色
let ポリオミノ = {};
let スコア;         // ゲームのスコア
let ゲームの状態; // ゲームの状態。「ゲーム中」と「クリア」がある

window.onload = function () {
  // キャンバスの要素オブジェクトを取得する
  canvas = document.getElementById("キャンバス");
  // キャンバスの大きさを変更する
  canvas.width = キャンバスの幅;
  canvas.height = キャンバスの高さ;
  // 2次元の描画コンテキストを取得する
  ctx = canvas.getContext("2d");

  // リセットボタンをクリックするとゲーム初期化処理が実行されるようにする  
  document.getElementById("リセットボタン").onclick = ゲーム初期化処理;
  // ウェブページ上でキーを押したときのイベントハンドラを設定する
  document.onkeydown = キー入力処理;

  // ゲームを初期化する
  ゲーム初期化処理();
};

// ゲームを新しく開始する際の初期化処理を行う関数
function ゲーム初期化処理() {
  // ゲーム盤上のブロックをすべてクリアする
  // ゲーム盤のブロックを空の配列で初期化する
  ゲーム盤のブロック = [];
  // 各列に対する繰り返し処理を行う
  for (let x = 0; x < ゲーム盤の列の数; x++) {
    // x列の要素に空の配列を代入する
    ゲーム盤のブロック[x] = [];
    // x列の各行に対する繰り返し処理を行う
    for (let y = 0; y < ゲーム盤の行の数; y++) {
      // 全ての(x, y) の組み合わせで下記のプログラムが実行される
      // 結果として「ゲーム盤のブロック」の全てのマスが「-1」になる
      ゲーム盤のブロック[x][y] = -1;
    }
  }

  // 繰り返し処理で「1」番と「2」番のブロックをランダムに配置する
  for (let ブロックの番号 = 1; ブロックの番号 <= 2; ブロックの番号++) {
    // 配置するブロックの数
    let ブロックの数 = 20;
    let 配置したブロックの数 = 0;
    while (配置したブロックの数 < ブロックの数) {
      // ブロックを1つランダムに配置する
      let x = サイコロを振る(ゲーム盤の列の数) - 1;
      let y = サイコロを振る(ゲーム盤の行の数) - 1;
      // 既にブロックが（x, y）にブロックが配置されていない事をチェックする
      // チェックする際に「false」を指定しない事！
      if (ゲーム盤のブロック[x][y] === -1) {
        // 配置済でなければ、「ブロックの番号」のブロックを配置し、
        //「配置した爆弾の数」数を1増やす
        ゲーム盤のブロック[x][y] = ブロックの番号;
        配置したブロックの数++;
      }
    }
  }
  // 右下のゴールのマスに、「6」番の水色のブロックを配置する
  ゲーム盤のブロック[ゲーム盤の列の数-1][ゲーム盤の行の数-1] = 6;

  // 新しいポリオミノを設定する
  新しいポリオミノの設定();

  // 点数を初期化する
  スコア = 0;
  // ゲームの状態を初期化する
  ゲームの状態 = "ゲーム中";

  // ポリオミノ.x = 0;
  // ポリオミノ.y = 0;

  // 画面描画する関数を呼び出す
  画面描画();
}

// －－－「画面の描画」に関する関数－－－－－－
// 画面全般を描画する関数
function 画面描画() {
  // キャンバスの描画をすべてクリアする
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 最初に全てのマスに、薄い灰色の枠を描画しておく
  for (let x = 0; x < ゲーム盤の列の数; x++) {
    for (let y = 0; y < ゲーム盤の行の数; y++) {
      ブロックの描画(x, y, "transparent", "lightgray");
    }
  }
  // ゲーム盤の枠を表示する
  ctx.beginPath();
  ctx.strokeStyle = "black";
  ctx.lineWidth = 1;
  ctx.rect(ゲーム盤の位置x, ゲーム盤の位置y,
    ゲーム盤の列の数 * マスの大きさ,
    ゲーム盤の行の数 * マスの大きさ);
  ctx.stroke();

  // ゲーム盤のブロックを表示する
  // 繰り返しを入れ子にすることで、全てのマスに対して処理を行う
  for (let x = 0; x < ゲーム盤の列の数; x++) {
    for (let y = 0; y < ゲーム盤の行の数; y++) {
      // (x, y) のマスのブロックの番号を取得する
      const ブロックの番号 = ゲーム盤のブロック[x][y];
      // ブロックが配置されているかどうかをチェックする
      if (ブロックの番号 >= 0) {
        // ブロックの番号に対応する色を取得し、ブロックを描画する関数を呼ぶ
        const 色 = ブロックの色[ブロックの番号];
        ブロックの描画(x, y, 色, "black");
      }
    }
  }

  // ポリオミノの描画を行う関数を呼ぶ
  ポリオミノの描画();

  let メッセージ;
  if (ゲームの状態 === "ゲーム中") {
    // ゲーム中は点数を「スコア 100 点」のように表示する
    メッセージ = "スコア" + スコア + "点";
  }
  else {
    // クリア時は点数を「クリア 100 点」のように表示する
    メッセージ = "クリア" + スコア + "点";
  }
  // メッセージを画面に表示する
  document.getElementById("スコア").innerHTML = メッセージ;
}


// ゲーム盤にブロックを描画する
// 引数一覧：
//  x, y：            ブロックを描画するゲーム盤上のマスの座標
//  塗りつぶしの色：　ブロックの塗りつぶしの色
//  枠の色：　　　　　ブロックの枠の色
function ブロックの描画(x, y, 塗りつぶしの色, 枠の色) {
  ctx.beginPath();
  ctx.lineWidth = 1;
  ctx.strokeStyle = 枠の色;
  ctx.fillStyle = 塗りつぶしの色;
  // ブロック表す長方形の左上の点の座標は、ゲーム盤の左上の座標である
  //（ゲーム盤の位置x, ゲーム盤の位置y）を基準とし、そこから
  // (x * マスの大きさ, y * マスの大きさ）だけずらした位置
  // ブロックの幅と高さは、「マスの大きさ」とおなじ
  ctx.rect(ゲーム盤の位置x + x * マスの大きさ,
    ゲーム盤の位置y + y * マスの大きさ,
    マスの大きさ, マスの大きさ);
  ctx.fill();
  ctx.stroke();
}

// ポリオミノを画面に描画する
function ポリオミノの描画() {
  // 「ブロックの描画」を使ってポリオミノのブロックを描画する
  ブロックの描画(ポリオミノ.x, ポリオミノ.y, ポリオミノ.色, "black");
}

// －－－－－－－－－－－－－－－－－－－－－－

// －－－「ポリオミノの処理」に関する関数－－－
// 新しいポリオミノを設定する関数
function 新しいポリオミノの設定() {
  // ポリオミノの最初の位置を(0, 0)に設定する
  ポリオミノ.x = 0;
  ポリオミノ.y = 0;
  // ポリオミノの種類の数は、ブロックの色の配列の要素数と同じ
  const ポリオミノの種類の数 = ブロックの色.length;
  // ポリオミノの種類の種類は赤いブロックを表す「0」とする。
  ポリオミノ.種類 = 0;
  // ポリオミノの種類に応じたブロックの色を設定する
  ポリオミノ.色 = ブロックの色[ポリオミノ.種類];
}

// ゲーム盤のポリオミノがあるマスに、ポリオミノのブロックを配置する
// その後、新しいポリオミノを設定する
function ポリオミノを配置する() {
  ゲーム盤のブロック[ポリオミノ.x][ポリオミノ.y] = ポリオミノ.種類;
  新しいポリオミノの設定();
}

// ポリオミノを移動しても良いかどうかをチェックし、
// 移動しても良い場合は「true」、そうでなければ「false」を返す
function ポリオミノを移動しても良いかどうか() {
  // ゲーム盤内の場合は移動しても良い
  return ゲーム盤内のマスかどうか(ポリオミノ.x,ポリオミノ.y);
}

// (x, y)のマスが、ゲーム盤内の場合は「true」、盤外の場合は「false」を返す関数
function ゲーム盤内のマスかどうか(x, y) {
  return 0 <= x && x < ゲーム盤の列の数 && 0 <= y && y < ゲーム盤の行の数;
}

// －－－－－－－－－－－－－－－－－－－－－－

// －－－「イベントハンドラ」に関する関数－－－
// キー入力処理を行う関数
function キー入力処理() {
  // ゲームの状態が「ゲーム中」でない場合は、この関数を終了する
  if (ゲームの状態 !== "ゲーム中") {
    return;
  }

  // ポリオミノの移動前の位置を覚えておく
  const 元の位置x = ポリオミノ.x;
  const 元の位置y = ポリオミノ.y;
  // 押されたキーに対応する処理を記述する
  switch (event.keyCode) {
    // 左のカーソルキー（37）が押された時の処理
    case 37:
      // ポリオミノを左に1マス移動する
      ポリオミノ.x--;
      break;
    // 右のカーソルキー（39）が押された時の処理
    case 39:
      // ポリオミノを右に1マス移動する
      ポリオミノ.x++;
      break;
    // 下のカーソルキー（40）が押された時の処理
    case 38:
      // ポリオミノを上に1マス移動する
      ポリオミノ.y--;
      break;
    // 下のカーソルキー（40）が押された時の処理
    case 40:
      // ポリオミノを下に1マス移動する
      ポリオミノ.y++;
      break;
  }

  // 移動後の場所にポリオミノを移動して良いかどうかをチェックする
  if (!ポリオミノを移動しても良いかどうか()) {
    // 移動してはいけない場合は、ポリオミノの位置を元に戻す
    ポリオミノ.x = 元の位置x;
    ポリオミノ.y = 元の位置y;
    // 下を押したときにブロックを配置する処理は必要がないので削除すること！
  }
  else {
    // 元の位置から移動しているかどうかをチェックする。元の位置から移動するのは、
    // ポリオミノのx座標または、y座標のどちらかが元の位置から変化していた場合
    if (ポリオミノ.x !== 元の位置x || ポリオミノ.y !== 元の位置y) {
      // ポリオミノの位置のブロックの番号で点数を変更する
    switch (ゲーム盤のブロック[ポリオミノ.x][ポリオミノ.y]) {
        // ブロックが配置されていない場合は「-1」点
        case -1:
          スコア--;
          break;
        // 「1」番の青いブロックの場合は「-3」点
        case 1:
          スコア = -3;
          break;
        // 「2」番の緑のブロックの場合は「+3」点
        case 2:
          スコア = +3;
          break;
        // 「6」番のゴールの場合は、ゲームの状態を「クリア」にする
        case 6:
          ゲームの状態 = "クリア";
          break;
      }
      // ポリオミノが移動したマスのブロックを削除する
      ゲーム盤のブロック[ポリオミノ.x][ポリオミノ.y] = -1;
    }
  }

  // 画面の描画を更新する
  画面描画();
}

// －－－－－－－－－－－－－－－－－－－－－－

// －－－「その他」の関数－－－－－－－－－－－
// １～出目の最大値までのランダムな数を返す関数
function サイコロを振る(出目の最大値) {
  return Math.floor(Math.random() * 出目の最大値) + 1;
}

// －－－－－－－－－－－－－－－－－－－－－－

